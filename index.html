<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>H2O Wet Wipe Tracker</title>
    <style>
        body {
            background-image: url('https://raw.githubusercontent.com/aquariumScream/h2oTracker.github.io/refs/heads/main/floor_plan.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        #reset-all-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            padding: 8px 12px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            font-size: 12px;
        }
        
        .dispenser {
            position: absolute;
            width: 85px;
            border: 2px solid #333;
            border-radius: 10px;
            padding: 8px;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            cursor: grab;
            user-select: none;
            touch-action: none;
        }

        .dispenser:active { cursor: grabbing; }
        .dispenser button {
            padding: 8px 12px;
            margin: 5px 0;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 12px;
            width: 100%;
        }
        .dispenser p { margin: 5px 0; font-size: 13px; color: #333; pointer-events: none; font-weight: bold; }

        /* Default Layouts (Fallbacks) */
        #dispenser1 { top: 5%; left: 2%; }
        #dispenser2 { top: 15%; left: 2%; }
        #dispenser3 { top: 25%; left: 2%; }
        #dispenser4 { top: 35%; left: 2%; }
        #dispenser5 { top: 45%; left: 2%; }
        #dispenser6 { top: 55%; left: 2%; }
        #dispenser7 { top: 65%; left: 2%; }
        #dispenser8 { top: 75%; left: 2%; }
        #dispenser9 { top: 85%; left: 2%; }
    </style>
</head>
<body>

    <button id="reset-all-btn" onclick="resetAllTimers()">Reset All</button>

    <div id="dispenser1" class="dispenser"><button onclick="handleReset('wipe1', 'reset')">Reset</button><button id="markBtn1" onclick="handleReset('wipe1', 'mark')">Mark</button><p id="timer1">0s</p></div>
    <div id="dispenser2" class="dispenser"><button onclick="handleReset('wipe2', 'reset')">Reset</button><button id="markBtn2" onclick="handleReset('wipe2', 'mark')">Mark</button><p id="timer2">0s</p></div>
    <div id="dispenser3" class="dispenser"><button onclick="handleReset('wipe3', 'reset')">Reset</button><button id="markBtn3" onclick="handleReset('wipe3', 'mark')">Mark</button><p id="timer3">0s</p></div>
    <div id="dispenser4" class="dispenser"><button onclick="handleReset('wipe4', 'reset')">Reset</button><button id="markBtn4" onclick="handleReset('wipe4', 'mark')">Mark</button><p id="timer4">0s</p></div>
    <div id="dispenser5" class="dispenser"><button onclick="handleReset('wipe5', 'reset')">Reset</button><button id="markBtn5" onclick="handleReset('wipe5', 'mark')">Mark</button><p id="timer5">0s</p></div>
    <div id="dispenser6" class="dispenser"><button onclick="handleReset('wipe6', 'reset')">Reset</button><button id="markBtn6" onclick="handleReset('wipe6', 'mark')">Mark</button><p id="timer6">0s</p></div>
    <div id="dispenser7" class="dispenser"><button onclick="handleReset('wipe7', 'reset')">Reset</button><button id="markBtn7" onclick="handleReset('wipe7', 'mark')">Mark</button><p id="timer7">0s</p></div>
    <div id="dispenser8" class="dispenser"><button onclick="handleReset('wipe8', 'reset')">Reset</button><button id="markBtn8" onclick="handleReset('wipe8', 'mark')">Mark</button><p id="timer8">0s</p></div>
    <div id="dispenser9" class="dispenser"><button onclick="handleReset('wipe9', 'reset')">Reset</button><button id="markBtn9" onclick="handleReset('wipe9', 'mark')">Mark</button><p id="timer9">0s</p></div>
    <div id="dispenser10" class="dispenser"><button onclick="handleReset('wipe10', 'reset')">Reset</button><button id="markBtn10" onclick="handleReset('wipe10', 'mark')">Mark</button><p id="timer10">0s</p></div>

    <script>
        const BIN_ID = "69879ea4d0ea881f40a89400";
        const MASTER_KEY = "$2a$10$hL5VMPRJSM1IAtw2DZ70GeBlpHNxWgMQU0VasqFgvRhiakRmmid.O";
        const BIN_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}`;
        
        // Single declaration
        let cloudData = { timers: {}, positions: {}, marked: {} };
        let dragging = null;
        let offset = { x: 0, y: 0 };
        let isDragging = false;
        let saveTimeout;
        
        // 1. Initial Fetch
        fetchCloudData();
        
        // 2. Refresh UI every 1s (local) & Sync Cloud every 15s
        setInterval(updateDisplays, 1000);
        setInterval(fetchCloudData, 15000);
        
        async function fetchCloudData() {
            try {
                const response = await fetch(BIN_URL + "/latest", {
                    headers: { "X-Master-Key": MASTER_KEY }
                });
                if (!response.ok) return; // Stop if API limit reached
                
                const json = await response.json();
                const raw = json.record || {};
                
                cloudData.timers = raw.timers || {};
                cloudData.positions = raw.positions || {};
                cloudData.marked = raw.marked || {};
        
                // Only snap boxes to cloud positions if we aren't currently dragging
                if (!dragging) {
                    Object.keys(cloudData.positions).forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                            const isMobile = window.innerWidth <= 600;
                            const posKey = isMobile ? 'mobile' : 'desktop';
                            const pos = cloudData.positions[id][posKey] || cloudData.positions[id];
                            if (pos && pos.left) {
                                el.style.left = pos.left;
                                el.style.top = pos.top;
                            }
                        }
                    });
                }
                updateDisplays();
            } catch (e) { console.error("Fetch failed", e); }
        }
        
        // 3. The "Save" Function (Throttled)
        function queuePush() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
                try {
                    await fetch(BIN_URL, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json', 'X-Master-Key': MASTER_KEY },
                        body: JSON.stringify(cloudData)
                    });
                    console.log("Positions saved to cloud.");
                } catch (e) { console.error("Save failed", e); }
            }, 2000); // Wait 2s after last movement to save
        }
        
        // 4. Dragging Logic (Instant Client-Side)
        function startDrag(e) {
            if (e.target.tagName === 'BUTTON') return;
            
            // Get correct coordinates for Mouse or Touch
            const event = e.type.includes('touch') ? e.touches[0] : e;
            
            dragging = e.currentTarget;
            isDragging = false;
            const rect = dragging.getBoundingClientRect();
            
            offset.x = event.clientX - rect.left;
            offset.y = event.clientY - rect.top;
            
            dragging.style.zIndex = 1000;
            dragging.style.cursor = 'grabbing';
        }
        
        function moveDrag(e) {
            if (!dragging) return;
            isDragging = true;
            
            const event = e.type.includes('touch') ? e.touches[0] : e;
            
            // Calculate new position %
            const xPct = (event.clientX - offset.x) / window.innerWidth * 100;
            const yPct = (event.clientY - offset.y) / window.innerHeight * 100;
            
            // MOVE INSTANTLY ON CLIENT
            dragging.style.left = xPct + '%';
            dragging.style.top = yPct + '%';
            
            if (e.cancelable) e.preventDefault();
        }
        
        function endDrag() {
            if (dragging) {
                if (isDragging) {
                    // Update local data object immediately
                    const isMobile = window.innerWidth <= 600;
                    const posKey = isMobile ? 'mobile' : 'desktop';
                    
                    if (!cloudData.positions[dragging.id]) cloudData.positions[dragging.id] = {};
                    
                    cloudData.positions[dragging.id][posKey] = {
                        left: dragging.style.left,
                        top: dragging.style.top
                    };
                    
                    // Queue the cloud update (doesn't block the UI)
                    queuePush();
                }
                
                dragging.style.zIndex = 1;
                dragging.style.cursor = 'grab';
                dragging = null;
                // Small delay to prevent accidental button clicks after drag
                setTimeout(() => { isDragging = false; }, 100);
            }
        }
        
        // 5. Timer & Mark Logic
        function handleReset(wipeId, action) {
            if (isDragging) return;
            if (action === 'reset') {
                cloudData.timers[wipeId] = Date.now();
                cloudData.marked[wipeId] = false;
            } else if (action === 'mark') {
                cloudData.marked[wipeId] = !cloudData.marked[wipeId];
            }
            updateDisplays();
            queuePush();
        }
        
        function updateDisplays() {
            for (let i = 1; i <= 10; i++) {
                const wipeId = 'wipe' + i;
                const lastTime = cloudData.timers[wipeId];
                const elapsed = lastTime ? Math.floor((Date.now() - lastTime) / 1000) : 0;
                const isMarked = cloudData.marked[wipeId];
                
                const timerEl = document.getElementById('timer' + i);
                if (timerEl) timerEl.textContent = formatTime(elapsed);
                
                const dispenser = document.getElementById('dispenser' + i);
                const isOverOneDay = elapsed > 86400;
        
                if (dispenser) {
                    dispenser.style.backgroundColor = isOverOneDay ? 'rgba(255, 100, 100, 0.9)' : 'rgba(255, 255, 255, 0.9)';
                }
        
                const markBtn = document.getElementById('markBtn' + i);
                if (markBtn) {
                    markBtn.style.backgroundColor = (isOverOneDay || isMarked) ? 'red' : '';
                    markBtn.style.color = (isOverOneDay || isMarked) ? 'white' : '';
                }
            }
        }
        
        function formatTime(s) {
            const d = Math.floor(s/86400), h = Math.floor((s%86400)/3600), m = Math.floor((s%3600)/60);
            let res = [];
            if (d > 0) res.push(d + 'd');
            if (h > 0) res.push(h + 'h');
            if (m > 0) res.push(m + 'm');
            res.push((s % 60) + 's');
            return res.join(' ');
        }
        
        // --- ATTACH LISTENERS ---
        document.querySelectorAll('.dispenser').forEach(el => {
            el.addEventListener('mousedown', startDrag);
            el.addEventListener('touchstart', startDrag, {passive: false});
        });
        
        document.addEventListener('mousemove', moveDrag);
        document.addEventListener('touchmove', moveDrag, {passive: false});
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);
    </script>
</body>
</html>
